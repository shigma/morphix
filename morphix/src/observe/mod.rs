//! Types and traits for observing mutations to data structures.
//!
//! This module provides the core observation infrastructure for morphix, including:
//!
//! - **Core traits**: [`Observe`] and [`Observer`] define the observation protocol
//! - **General-purpose observers**: [`GeneralObserver`], handler trait [`GeneralHandler`] for
//!   implementing custom detection strategies, and pre-configured types: [`ShallowObserver`],
//!   [`SnapshotObserver`], [`HashObserver`], [`NoopObserver`]
//! - **Specialized observers**: Type-specific implementations for [`String`] and [`Vec<T>`]
//! - **Internal types**: [`MutationState`] and [`StatefulObserver`] for advanced implementations
//!
//! ## Observer Hierarchy
//!
//! ```text
//! Observer
//! ├── GeneralObserver             - Configurable via handlers
//! │   ├── HashObserver            - Compares hash values
//! │   ├── NoopObserver            - Ignores all changes
//! │   ├── ShallowObserver         - Tracks any DerefMut access
//! │   └── SnapshotObserver        - Compares cloned values
//! ├── StatefulObserver            - Tracks appends
//! │   ├── StringObserver          - Specialized for String
//! │   └── VecObserver             - Specialized for Vec
//! └── {Type}Observer              - Generated by #[derive(Observe)]
//! ```
//!
//! ## Usage
//!
//! Most users will interact with this module through attributes like `#[observe(shallow)]` for
//! field-level control. Direct use of types from this module is typically only needed for advanced
//! use cases.

use std::ops::DerefMut;

use serde::Serialize;

use crate::helper::{AsDerefCoinductive, AsDerefMut, Pointer, Unsigned, Zero};
use crate::{Adapter, Mutation};

mod general;
mod hash;
mod noop;
mod shallow;
mod snapshot;

pub use general::{DebugHandler, GeneralHandler, GeneralObserver};
pub use hash::{HashObserver, HashSpec};
pub use noop::NoopObserver;
pub use shallow::ShallowObserver;
pub use snapshot::{SnapshotObserver, SnapshotSpec};

/// A trait for types that can be observed for mutations.
///
/// Types implementing `Observe` can be wrapped in [`Observer`]s that track mutations. The trait is
/// typically derived using the `#[derive(Observe)]` macro and used in `observe!` macros.
///
/// A single type `T` may have many possible [`Observer<'i, Target = T>`] implementations in
/// theory, each with different change-tracking strategies. The `Observe` trait selects one
/// of these as the default observer to be used by `#[derive(Observe)]` and other generic code
/// that needs an observer for `T`.
///
/// When you `#[derive(Observe)]` on a struct, the macro requires that each field type
/// implements `Observe` so it can select an appropriate default observer for that field.
/// The `Observer` associated type of each field's `Observe` implementation determines which
/// observer will be instantiated in the generated code.
///
/// ## Example
///
/// ```
/// use morphix::{JsonAdapter, Observe, observe};
/// use serde::Serialize;
///
/// #[derive(Serialize, Observe)]
/// struct MyStruct {
///     field: String,
/// }
///
/// let mut data = MyStruct { field: "value".to_string() };
/// observe!(JsonAdapter, |mut data| {
///     // Mutations through observer are tracked
///     data.field.push_str(" modified");
/// });
/// ```
pub trait Observe: Serialize {
    /// Associated observer type.
    ///
    /// This associated type specifies the *default* observer implementation for the type, when used
    /// in contexts where an [`Observe`] implementation is required.
    type Observer<'i, S, N>: Observer<Head = S, UpperDepth = N>
    where
        Self: 'i,
        N: Unsigned,
        S: AsDerefMut<N, Target = Self> + ?Sized + 'i;

    /// Associated specification type for this observable.
    ///
    /// The `Spec` associated type is used as a marker to select specialized implementations of
    /// observers in certain contexts. For most types, this will be [`DefaultSpec`], but types
    /// can specify alternative specs to enable specialized observation strategies.
    ///
    /// ## Usage
    ///
    /// One important use of `Spec` is to select the appropriate observer implementation for wrapper
    /// types like [`Option<T>`]:
    ///
    /// - [`DefaultSpec`] → use `OptionObserver` wrapping `T`'s observer
    /// - [`SnapshotSpec`] → use [`SnapshotObserver<Option<T>>`] for snapshot-based change detection
    /// - [`HashSpec`] → use [`HashObserver<Option<T>>`] for hash-based change detection
    ///
    /// This allows [`Option<T>`] to automatically inherit more accurate or efficient change
    /// detection strategies based on its element type, without requiring manual implementation.
    type Spec;
}

/// A trait for observer types that wrap and track mutations to values.
///
/// Observers provide transparent access to the underlying value while recording any mutations that
/// occur.
///
/// ## Construction
///
/// Observers can be constructed in two ways:
/// 1. Via [`Observer::observe`] - creates an observer for an existing value
/// 2. Via [`Default::default`] - creates an empty observer with a null pointer
pub trait Observer
where
    Self: DerefMut<Target: AsDerefCoinductive<Self::LowerDepth, Target = Pointer<Self::Head>>>,
{
    type UpperDepth: Unsigned;
    type LowerDepth: Unsigned;
    type Head: AsDerefMut<Self::UpperDepth> + ?Sized;

    /// Creates a new observer for the given value.
    ///
    /// This is the primary way to create an observer. The observer will track all mutations to the
    /// provided value.
    ///
    /// ## Example
    ///
    /// ```rust
    /// use morphix::Observer;
    /// use morphix::observe::ShallowObserver;
    ///
    /// let mut value = 42;
    /// let observer = ShallowObserver::observe(&mut value);
    /// ```
    fn observe(value: &mut Self::Head) -> Self;

    fn as_ptr(this: &Self) -> &Pointer<Self::Head> {
        (**this).as_deref_coinductive()
    }

    /// Collects all recorded mutations (unsafe version).
    ///
    /// ## Safety
    ///
    /// This method assumes the observer contains a valid (non-null) pointer. Calling this on a
    /// default-constructed observer results in *undefined behavior*.
    ///
    /// Most users should call [`Observer::collect`] instead, which includes a null pointer check.
    ///
    /// ## Implementation Notes
    ///
    /// Implementations can safely use [`Deref`](std::ops::Deref) and [`DerefMut`] to access the
    /// observed value, as this method is only called when the observer contains a valid pointer.
    /// The observer's [`Deref`](std::ops::Deref) and [`DerefMut`] implementations are guaranteed to
    /// be safe when `collect_unchecked` is called.
    ///
    /// ```ignore
    /// unsafe fn collect_unchecked<A: Adapter>(this: Self) -> Result<Option<Mutation<A>>, A::Error> {
    ///     // Safe to dereference
    ///     collect_mutation(&*this)
    /// }
    /// ```
    unsafe fn collect_unchecked<A: Adapter>(this: &mut Self) -> Result<Option<Mutation<A>>, A::Error>;

    /// Collects all recorded mutations using the specified adapter.
    ///
    /// This is the safe version that checks for null pointers before collecting.
    /// Default-constructed observers will return `Ok(None)`.
    ///
    /// ## Returns
    ///
    /// - `None` if no mutations were recorded or if the observer is empty (null pointer)
    /// - otherwise a [`Mutation`] containing all mutations that occurred
    ///
    /// ## Errors
    ///
    /// Returns an error if serialization fails.
    ///
    /// ## Example
    ///
    /// ```rust
    /// use morphix::{Observer, JsonAdapter};
    /// use morphix::observe::ShallowObserver;
    ///
    /// // Normal usage
    /// let mut value = 42;
    /// let mut observer = ShallowObserver::observe(&mut value);
    /// observer += 1;
    /// let mutation = Observer::collect::<JsonAdapter>(observer).unwrap();
    /// assert!(mutation.is_some());
    ///
    /// // Safe handling of default-constructed observer
    /// let empty: ShallowObserver<i32> = Default::default();
    /// let result = Observer::collect::<JsonAdapter>(empty).unwrap();
    /// assert_eq!(result, None);   // Returns None instead of panicking
    /// ```
    fn collect<A: Adapter>(this: &mut Self) -> Result<Option<Mutation<A>>, A::Error> {
        if Self::as_ptr(this).is_null() {
            return Ok(None);
        }
        unsafe { Self::collect_unchecked(this) }
    }
}

/// Default observation specification.
///
/// `DefaultSpec` indicates that no special observation behavior is required for the type. For most
/// types, this means they use their standard `Observer` implementation. For example, if `T`
/// implements [`Observe`] with `Spec = DefaultSpec`, then [`Option<T>`] will be observed using
/// `OptionObserver` which wraps `T`'s observer.
///
/// All `#[derive(Observe)]` implementations use `DefaultSpec` unless overridden with field
/// attributes.
pub struct DefaultSpec;

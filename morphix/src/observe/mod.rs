//! Types and traits for observing mutations to data structures.
//!
//! This module provides the core observation infrastructure for morphix, including:
//!
//! - **Core traits**: [`Observe`] and [`Observer`] define the observation protocol
//! - **General-purpose observers**: [`GeneralObserver`], handler trait [`GeneralHandler`] for
//!   implementing custom detection strategies, and pre-configured types: [`ShallowObserver`],
//!   [`SnapshotObserver`], [`HashObserver`], [`NoopObserver`]
//! - **Specialized observers**: Type-specific implementations for [`String`] and [`Vec`]
//! - **Internal types**: [`MutationState`] and [`StatefulObserver`] for advanced implementations
//!
//! ## Observer Hierarchy
//!
//! ```text
//! Observer
//! ├── GeneralObserver             - Configurable via handlers
//! │   ├── HashObserver            - Compares hash values
//! │   ├── NoopObserver            - Ignores all changes
//! │   ├── ShallowObserver         - Tracks any DerefMut access
//! │   └── SnapshotObserver        - Compares cloned values
//! ├── StatefulObserver            - Tracks appends
//! │   ├── StringObserver          - Specialized for String
//! │   └── VecObserver             - Specialized for Vec
//! └── {Type}Observer              - Generated by #[derive(Observe)]
//! ```
//!
//! ## Usage
//!
//! Most users will interact with this module through attributes like `#[observe(shallow)]` for
//! field-level control. Direct use of types from this module is typically only needed for advanced
//! use cases.

use std::ops::DerefMut;

use serde::Serialize;

use crate::{Adapter, Mutation};

mod general;
mod hash;
mod noop;
mod shallow;
mod snapshot;

pub use general::{GeneralHandler, GeneralObserver};
pub use hash::HashObserver;
pub use noop::NoopObserver;
pub use shallow::ShallowObserver;
pub use snapshot::SnapshotObserver;

/// A trait for types that can be observed for mutations.
///
/// Types implementing `Observe` can be wrapped in [`Observer`]s that track mutations.
/// The trait is typically derived using the `#[derive(Observe)]` macro.
///
/// ## Example
///
/// ```
/// use morphix::{JsonAdapter, Observe, observe};
/// use serde::Serialize;
///
/// #[derive(Serialize, Observe)]
/// struct MyStruct {
///     field: String,
/// }
///
/// let mut data = MyStruct { field: "value".to_string() };
/// observe!(JsonAdapter, |mut data| {
///     // Mutations through observer are tracked
///     data.field.push_str(" modified");
/// });
/// ```
///
/// [`Observers`]: crate::Observer
pub trait Observe: Serialize {
    /// Associated observer type.
    type Observer<'i>: Observer<'i, Target = Self>
    where
        Self: 'i;

    /// Helper method for `#[derive(Observe)]`.
    ///
    /// The default implementation simply calls `Self::Observer::observe(self)`.
    #[doc(hidden)]
    #[inline]
    fn __observe<'i>(&'i mut self) -> Self::Observer<'i> {
        Self::Observer::observe(self)
    }
}

/// A trait for observer types that wrap and track mutations to values.
///
/// Observers provide transparent access to the underlying value while recording any mutations that
/// occur.
///
/// ## Construction
///
/// Observers can be constructed in two ways:
/// 1. Via [`Observer::observe`] - creates an observer for an existing value
/// 2. Via [`Default::default`] - creates an empty observer with a null pointer
pub trait Observer<'i>: DerefMut + Sized {
    /// Returns the raw pointer to the observed value.
    ///
    /// This method provides access to the underlying pointer that the observer is tracking. It's
    /// primarily used internally for advanced operations that need direct pointer access.
    ///
    /// ## Returns
    ///
    /// - A valid pointer to the observed value if created via [`Observer::observe`]
    /// - A null pointer if created via [`Default::default`]
    ///
    /// ## Safety Considerations
    ///
    /// - The returned pointer is only valid for the lifetime `'i`
    /// - The pointer must not be used after the observer is dropped
    /// - Mutations through this pointer bypass the observer's tracking mechanisms
    ///
    /// ## Example
    ///
    /// ```rust
    /// use morphix::Observer;
    /// use morphix::observe::ShallowObserver;
    ///
    /// let mut value = 42i32;
    /// let observer = ShallowObserver::observe(&mut value);
    ///
    /// // Get the raw pointer (same as &mut value)
    /// let inner_ptr = Observer::inner(&observer);
    /// assert!(!inner_ptr.is_null());
    ///
    /// // Default-constructed observer returns null
    /// let observer: ShallowObserver<i32> = Default::default();
    /// let null_ptr = Observer::inner(&observer);
    /// assert!(null_ptr.is_null());
    /// ```
    fn inner(this: &Self) -> *mut Self::Target;

    /// Creates a new observer for the given value.
    ///
    /// This is the primary way to create an observer. The observer will track all mutations to the
    /// provided value.
    ///
    /// ## Example
    ///
    /// ```rust
    /// use morphix::Observer;
    /// use morphix::observe::ShallowObserver;
    ///
    /// let mut value = 42;
    /// let observer = ShallowObserver::observe(&mut value);
    /// ```
    fn observe(value: &'i mut Self::Target) -> Self;

    /// Collects all recorded mutations (unsafe version).
    ///
    /// ## Safety
    ///
    /// This method assumes the observer contains a valid (non-null) pointer. Calling this on a
    /// default-constructed observer results in *undefined behavior*.
    ///
    /// Most users should call [`Observer::collect`] instead, which includes a null pointer check.
    ///
    /// ## Implementation Notes
    ///
    /// Implementations can safely use [`Deref`](std::ops::Deref) and [`DerefMut`] to access the
    /// observed value, as this method is only called when the observer contains a valid pointer.
    /// The observer's [`Deref`](std::ops::Deref) and [`DerefMut`] implementations are guaranteed to
    /// be safe when `collect_unchecked` is called.
    ///
    /// ```ignore
    /// unsafe fn collect_unchecked<A: Adapter>(this: Self) -> Result<Option<Mutation<A>>, A::Error> {
    ///     // Safe to dereference
    ///     collect_mutation(&*this)
    /// }
    /// ```
    unsafe fn collect_unchecked<A: Adapter>(this: Self) -> Result<Option<Mutation<A>>, A::Error>
    where
        Self::Target: Serialize;

    /// Collects all recorded mutations using the specified adapter.
    ///
    /// This is the safe version that checks for null pointers before collecting.
    /// Default-constructed observers will return `Ok(None)`.
    ///
    /// ## Returns
    ///
    /// - `None` if no mutations were recorded or if the observer is empty (null pointer)
    /// - otherwise a [`Mutation`] containing all mutations that occurred
    ///
    /// ## Errors
    ///
    /// Returns an error if serialization fails.
    ///
    /// ## Example
    ///
    /// ```rust
    /// use morphix::{Observer, JsonAdapter};
    /// use morphix::observe::ShallowObserver;
    ///
    /// // Normal usage
    /// let mut value = 42;
    /// let mut observer = ShallowObserver::observe(&mut value);
    /// observer += 1;
    /// let mutation = Observer::collect::<JsonAdapter>(observer).unwrap();
    /// assert!(mutation.is_some());
    ///
    /// // Safe handling of default-constructed observer
    /// let empty: ShallowObserver<i32> = Default::default();
    /// let result = Observer::collect::<JsonAdapter>(empty).unwrap();
    /// assert_eq!(result, None);   // Returns None instead of panicking
    /// ```
    fn collect<A: Adapter>(this: Self) -> Result<Option<Mutation<A>>, A::Error>
    where
        Self::Target: Serialize,
    {
        if Self::inner(&this).is_null() {
            return Ok(None);
        }
        unsafe { Self::collect_unchecked(this) }
    }
}

/// State of mutations tracked by a [`StatefulObserver`].
///
/// This enum represents the specific type of mutation that has been detected by observers that
/// implement [`StatefulObserver`].
#[derive(Clone, Copy)]
pub enum MutationState {
    /// Complete replacement of the value
    Replace,
    /// Append operation starting from the given index
    Append(usize),
}

/// An [`Observer`] that maintains internal state about mutations.
///
/// Unlike [`ShallowObserver`] which only tracks whether a mutation occurred, `StatefulObserver`
/// implementations can distinguish between different types of mutations (replace vs. append) and
/// optimize the resulting mutation representation accordingly.
///
/// ## Implementation Notes
///
/// Implementing `StatefulObserver` allows an observer to track its own mutation state (e.g.,
/// replace or append), but this doesn't preclude tracking additional mutations. Complex types like
/// [`Vec`] may need to track both:
///
/// - Their own mutation state (via `StatefulObserver`)
/// - Changes to their elements (via nested observers)
///
/// These different sources of mutations are then combined into a final result:
///
/// ```ignore
/// // Example from VecObserver implementation
/// impl<'i, T: Observe> Observer<'i, Vec<T>> for VecObserver<'i, T> {
///     fn collect<A: Adapter>(mut this: Self) -> Result<Option<Mutation<A>>, A::Error> {
///         let mut mutations = vec![];
///
///         // 1. Collect own mutation state (replacement or append)
///         if let Some(state) = Self::mutation_state(&mut this).take() {
///             mutations.push(Mutation {
///                 operation: match state {
///                     MutationState::Replace => MutationKind::Replace(..),
///                     MutationState::Append(idx) => MutationKind::Append(..),
///                 },
///                 // ...
///             });
///         }
///
///         // 2. Collect mutations from nested element observers
///         for (index, observer) in element_observers {
///             if let Some(mutation) = observer.collect()? {
///                 mutations.push(mutation);
///             }
///         }
///
///         // 3. Combine all mutations (may result in a Batch)
///         Ok(Batch::build(mutations))
///     }
/// }
/// ```
///
/// This design allows for sophisticated mutation tracking where:
/// - Simple operations (like `vec.push()`) produce an `Append` mutation
/// - Element modifications (like `vec[0].field = value`) produce element-specific mutations
/// - Multiple operations produce a `Batch` containing all mutations
///
/// Currently implemented for:
/// - [`String`]
/// - [`Vec<T>`]
pub trait StatefulObserver<'i>: Observer<'i> {
    fn mutation_state(this: &mut Self) -> &mut Option<MutationState>;

    fn mark_replace(this: &mut Self) {
        *Self::mutation_state(this) = Some(MutationState::Replace);
    }

    fn mark_append(this: &mut Self, start_index: usize) {
        let mutation = Self::mutation_state(this);
        if mutation.is_some() {
            return;
        }
        *mutation = Some(MutationState::Append(start_index));
    }
}

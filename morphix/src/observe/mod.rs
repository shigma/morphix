//! Types and traits for observing mutations to data structures.
//!
//! This module provides the core observation infrastructure for morphix, including:
//!
//! - **Core traits**: [`Observe`] and [`Observer`] define the observation protocol
//! - **General-purpose observers**: [`GeneralObserver`], handler trait [`GeneralHandler`] for
//!   implementing custom detection strategies, and pre-configured types: [`ShallowObserver`],
//!   [`SnapshotObserver`], [`HashObserver`], [`NoopObserver`]
//! - **Specialized observers**: Type-specific implementations for common types, such as [`String`]
//!   and [`Vec<T>`]
//!
//! ## How Observers Work
//!
//! Observers are types that implement [`DerefMut`](std::ops::DerefMut) to the target type being
//! observed. When any method requiring `&mut self` is called, it triggers the
//! [`DerefMut`](std::ops::DerefMut) hook where change tracking occurs. Additionally, for specific
//! methods like [`String::push_str`] and [`Vec::push`], observers provide specialized
//! implementations for more precise tracking.
//!
//! For types that already implement [`Deref`](std::ops::Deref) (like [`Box<T>`]), implementing
//! observers is more challenging. If type `A` dereferences to `B`, and we have corresponding
//! observers `A'` and `B'`, where should `A'` deref to?
//!
//! - If `A'` → `A` → `B`: Changes on B cannot be precisely tracked (because no `B'` in the
//!   dereference chain)
//! - If `A'` → `B'` → `B`: Properties and methods on A become inaccessible (because no `A` in the
//!   dereference chain)
//!
//! To solve this, we use a [`ObserverPointer`] type to create the dereference chain: `A'` → `B'` →
//! `ObserverPointer<A>` → `A` → `B`. This allows tracking changes on both `A` and `B`.
//!
//! ## Observer Hierarchy
//!
//! ```text
//! Observer
//! ├── GeneralObserver
//! │   ├── HashObserver            - Compares hash values
//! │   ├── NoopObserver            - Ignores all changes
//! │   ├── ShallowObserver         - Tracks any DerefMut access
//! │   └── SnapshotObserver        - Compares cloned values
//! ├── Specialized Observers
//! │   ├── StringObserver          - Specialized for String
//! │   └── VecObserver             - Specialized for Vec
//! └── {Type}Observer              - Generated by #[derive(Observe)]
//! ```
//!
//! ## Usage
//!
//! Most users will interact with this module through attributes like `#[observe(shallow)]` for
//! field-level control. Direct use of types from this module is typically only needed for advanced
//! use cases.

use crate::helper::{AsDeref, AsDerefMut, AsDerefMutCoinductive, Succ, Unsigned, Zero};
use crate::{Adapter, Mutation};

mod general;
mod hash;
mod noop;
mod pointer;
mod shallow;
mod snapshot;

pub use general::{DebugHandler, GeneralHandler, GeneralObserver};
pub use hash::{HashObserver, HashSpec};
pub use noop::NoopObserver;
pub use pointer::ObserverPointer;
pub use shallow::ShallowObserver;
pub use snapshot::{SnapshotObserver, SnapshotSpec};

/// A trait for types that can be observed for mutations.
///
/// Types implementing `Observe` can be wrapped in [`Observer`]s that track mutations. The trait is
/// typically derived using the `#[derive(Observe)]` macro and used in `observe!` macros.
///
/// A single type `T` may have many possible [`Observer<'i, Target = T>`] implementations in
/// theory, each with different change-tracking strategies. The `Observe` trait selects one
/// of these as the default observer to be used by `#[derive(Observe)]` and other generic code
/// that needs an observer for `T`.
///
/// When you `#[derive(Observe)]` on a struct, the macro requires that each field type
/// implements `Observe` so it can select an appropriate default observer for that field.
/// The `Observer` associated type of each field's `Observe` implementation determines which
/// observer will be instantiated in the generated code.
///
/// ## Example
///
/// ```
/// use morphix::{JsonAdapter, Observe, observe};
/// use serde::Serialize;
///
/// #[derive(Serialize, Observe)]
/// struct MyStruct {
///     field: String,
/// }
///
/// let mut data = MyStruct { field: "value".to_string() };
/// observe!(JsonAdapter, |mut data| {
///     // Mutations through observer are tracked
///     data.field.push_str(" modified");
/// });
/// ```
pub trait Observe {
    /// Associated observer type.
    ///
    /// This associated type specifies the *default* observer implementation for the type, when used
    /// in contexts where an [`Observe`] implementation is required.
    type Observer<'i, S, D>: Observer<'i, Head = S, InnerDepth = D>
    where
        Self: 'i,
        D: Unsigned,
        S: AsDerefMut<D, Target = Self> + ?Sized + 'i;

    /// Associated specification type for this observable.
    ///
    /// The `Spec` associated type is used as a marker to select specialized implementations of
    /// observers in certain contexts. For most types, this will be [`DefaultSpec`], but types
    /// can specify alternative specs to enable specialized observation strategies.
    ///
    /// ## Usage
    ///
    /// One important use of `Spec` is to select the appropriate observer implementation for wrapper
    /// types like [`Option<T>`]:
    ///
    /// - [`DefaultSpec`] → use [`OptionObserver`](crate::impls::option::OptionObserver) wrapping
    ///   `T`'s observer
    /// - [`SnapshotSpec`] → use [`SnapshotObserver<Option<T>>`] for snapshot-based change detection
    /// - [`HashSpec`] → use [`HashObserver<Option<T>>`] for hash-based change detection
    ///
    /// This allows [`Option<T>`] to automatically inherit more accurate or efficient change
    /// detection strategies based on its element type, without requiring manual implementation.
    type Spec;
}

/// Extension trait providing ergonomic methods for types implementing [`Observe`].
///
/// This trait is automatically implemented for all types that implement [`Observe`] and provides a
/// convenient way to create observers without needing to specify type parameters.
///
/// ## Example
///
/// ```
/// use morphix::observe::ObserveExt;
///
/// let mut data = 42;
/// let ob = data.observe();
/// ```
pub trait ObserveExt: Observe {
    /// Creates an observer for this value.
    ///
    /// This is a convenience method that calls [`Observer::observe`] with the appropriate type
    /// parameters automatically inferred.
    #[inline]
    fn observe<'i>(&'i mut self) -> Self::Observer<'i, Self, Zero> {
        Observer::observe(self)
    }
}

impl<T: Observe> ObserveExt for T {}

/// A trait for observer types that wrap and track mutations to values.
///
/// Observers provide transparent access to the underlying value while recording any mutations that
/// occur. They form a dereference chain that allows multiple levels of observation.
///
/// ## Type Parameters
///
/// - `Head`: The type stored in the internal [`ObserverPointer`], representing the head of the
///   dereference chain
/// - `InnerDepth`: Type-level number indicating how many times `Head` must be dereferenced to reach
///   the observed type
/// - `OuterDepth`: Type-level number indicating how many times `Self` must be dereferenced (plus
///   one) to reach [`ObserverPointer<Head>`]
///
/// See the [module documentation](self) for more details about how observers work with dereference
/// chains.
pub trait Observer<'i>
where
    Self: Default,
    Self: AsDerefMutCoinductive<Succ<Self::OuterDepth>, Target = ObserverPointer<Self::Head>>,
{
    /// Type-level number of dereferences from `Head` to the observed type.
    type InnerDepth: Unsigned;
    /// Type-level number of dereferences from `Self` to [`ObserverPointer<Head>`] minus one.
    type OuterDepth: Unsigned;
    /// The head type of the dereference chain.
    type Head: AsDerefMut<Self::InnerDepth> + ?Sized + 'i;

    /// Creates a new observer for the given value.
    ///
    /// This is the primary way to create an observer. The observer will track all mutations to the
    /// provided value.
    ///
    /// ## Example
    ///
    /// ```
    /// use morphix::observe::{Observer, ShallowObserver};
    ///
    /// let mut value = 42;
    /// let observer = ShallowObserver::<i32>::observe(&mut value);
    /// ```
    fn observe(value: &'i mut Self::Head) -> Self;

    /// Gets a reference to the internal pointer.
    ///
    /// This is primarily used internally by observer implementations.
    fn as_ptr(this: &Self) -> &ObserverPointer<Self::Head> {
        this.as_deref_coinductive()
    }

    /// Gets a mutable reference to the inner observed value.
    ///
    /// This method traverses the entire dereference chain to reach the observed value, bypassing
    /// any observation logic.
    fn as_inner<'j>(this: &Self) -> &'j mut <Self::Head as AsDeref<Self::InnerDepth>>::Target
    where
        'i: 'j,
    {
        let head = unsafe { ObserverPointer::as_mut(Self::as_ptr(this)) };
        AsDerefMut::<Self::InnerDepth>::as_deref_mut(head)
    }
}

/// Trait for observers that can serialize their collected mutations.
///
/// This trait extends [`Observer`] with the ability to collect and serialize mutations using a
/// specific [`Adapter`].
pub trait SerializeObserver<'i>: Observer<'i> {
    /// Collects all recorded mutations (unsafe version).
    ///
    /// ## Safety
    ///
    /// This method assumes the observer contains a valid (non-null) pointer. Calling this on a
    /// default-constructed observer results in *undefined behavior*.
    ///
    /// Most users should call [`collect`](SerializeObserver::collect) instead, which includes a
    /// null pointer check.
    ///
    /// ## Implementation Notes
    ///
    /// Implementations can safely use [`Deref`](std::ops::Deref) and
    /// [`DerefMut`](std::ops::DerefMut) to access the observed value, as this method is only
    /// called when the observer contains a valid pointer. The observer's
    /// [`Deref`](std::ops::Deref) and [`DerefMut`](std::ops::DerefMut) implementations are
    /// guaranteed to be safe when `collect_unchecked` is called.
    ///
    /// ```ignore
    /// unsafe fn collect_unchecked<A: Adapter>(this: Self) -> Result<Option<Mutation<A>>, A::Error> {
    ///     // Safe to dereference
    ///     collect_mutation(&*this)
    /// }
    /// ```
    unsafe fn collect_unchecked<A: Adapter>(this: &mut Self) -> Result<Option<Mutation<A>>, A::Error>;

    /// Collects all recorded mutations using the specified adapter.
    ///
    /// - Returns [`Ok(None)`](std::result::Result::Ok) if no mutations is recorded or the observer
    ///   is null
    /// - Returns [`Err`] if serialization fails.
    ///
    /// ## Example
    ///
    /// ```
    /// use morphix::JsonAdapter;
    /// use morphix::observe::{ObserveExt, SerializeObserverExt, ShallowObserver};
    ///
    /// // Normal usage
    /// let mut value = String::from("Hello");
    /// let mut ob = value.observe();
    /// ob += " world";
    /// let mutation = ob.collect::<JsonAdapter>().unwrap();
    /// assert!(mutation.is_some());
    ///
    /// // Safe handling of default-constructed observer
    /// let mut empty: ShallowObserver<i32> = Default::default();
    /// let result = empty.collect::<JsonAdapter>().unwrap();
    /// assert_eq!(result, None);   // Returns None instead of panicking
    /// ```
    fn collect<A: Adapter>(this: &mut Self) -> Result<Option<Mutation<A>>, A::Error> {
        if ObserverPointer::is_null(Self::as_ptr(this)) {
            return Ok(None);
        }
        unsafe { Self::collect_unchecked(this) }
    }
}

/// Extension trait providing ergonomic methods for [`SerializeObserver`].
///
/// This trait is automatically implemented for all types that implement [`SerializeObserver`] and
/// provides convenient methods that don't require turbofish syntax.
pub trait SerializeObserverExt<'i>: SerializeObserver<'i> {
    /// Collects mutations using the specified adapter.
    ///
    /// This is a convenience method that calls [`SerializeObserver::collect`].
    #[inline]
    fn collect<A: Adapter>(&mut self) -> Result<Option<Mutation<A>>, <A>::Error> {
        SerializeObserver::collect(self)
    }
}

impl<'i, T: SerializeObserver<'i>> SerializeObserverExt<'i> for T {}

/// Default observation specification.
///
/// `DefaultSpec` indicates that no special observation behavior is required for the type. For most
/// types, this means they use their standard `Observer` implementation. For example, if `T`
/// implements [`Observe`] with `Spec = DefaultSpec`, then [`Option<T>`] will be observed using
/// `OptionObserver` which wraps `T`'s observer.
///
/// All `#[derive(Observe)]` implementations use `DefaultSpec` unless overridden with field
/// attributes.
pub struct DefaultSpec;

#[doc(hidden)]
pub type DefaultObserver<'i, T> = <T as Observe>::Observer<'i, T, Zero>;
